# hw3

# **Система контроля версий**

**Cистема контроля версий (VCS)** — программное обеспечение для облегчения работы с изменяющейся информацией.

* _**Полная история изменений каждого файла за длительный период.**_ Это касается всех изменений, внесенных огромным количеством людей за долгие годы. Изменением считается создание и удаление файлов, а также редактирование их содержимого. Различные инструменты VCS отличаются тем, насколько хорошо они обрабатывают операции переименования и перемещения файлов. В историю также должны входить сведения об авторе, дата и комментарий с описанием цели каждого изменения. Наличие полной истории позволяет возвращаться к предыдущим версиям, чтобы проводить анализ основных причин возникновения ошибок и устранять проблемы в старых версиях программного обеспечения. 

* _**Ветвление и слияние.**_ Создание «веток» позволяет иметь несколько независимых друг от друга направлений разработки, а также выполнять их слияние, чтобы разработчики могли проверить, что изменения, внесенные в каждую из веток, не конфликтуют друг с другом. Многие команды разработчиков программного обеспечения создают отдельные ветки для каждой функциональной возможности, для каждого релиза либо и для того, и для другого.

* _**Отслеживаемость.**_ Возможность отслеживать каждое изменение, внесенное в программное обеспечение, и связывать его с ПО для управления проектами и отслеживания ошибок. История с комментариями во время чтения кода помогает понять, что этот код делает и почему действие реализовано именно таким образом. Благодаря этому разработчики могут вносить корректные и совместимые изменения в соответствии с долгосрочным планом разработки системы. 


## **Подготовка к работе**
1.	Скачать и установить [VS Code](https://code.visualstudio.com/docs/?dv=win) 

2.	Скачать и установить [Git](https://git-scm.com/download/win)

3.	Проверить, работает ли git  с помощью команды `git --version`

4.	Добавить _**имя**_ и _**email**_ пользователя с помощью команд
  * `git config --global user.email "email@mail.com"`

  * `git config --global user.name "User Name"`

  ## **Команды**

### 1. _**Создание репозитария. Подготовка файлов**_
* _**`git init`**_
    
    Эта команда создаёт в текущем каталоге новый подкаталог с именем *.git*, содержащий все необходимые файлы репозитория — структуру Git репозитория. 
    
    ! На этом этапе ваш проект ещё не находится под версионным контролем. 

    Если вы хотите добавить под версионный контроль существующие файлы (в отличие от пустого каталога), вам стоит добавить их в индекс и осуществить первый коммит изменений. Добиться этого вы сможете запустив команду *`git add`* несколько раз, указав индексируемые файлы, а затем выполнив *`git commit`*.

* _**`git add`**_

    Команда *`git add`* добавляет содержимое рабочего каталога (все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий) в индекс (*staging area*) для последующего коммита. 
    
    По умолчанию *`git commit`* использует лишь этот индекс, так что вы можете использовать *`git add`* для сборки слепка вашего следующего коммита.
    
* _**`git commit`**_
    
    Команда *`git commit`* берёт все данные, добавленные в индекс с помощью *`git add`*, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

    Команда *`git commit`* используется с ключом *`-m`* после которого в двойных ковычках указывается комментарий к текущему коммиту.

    Использование ключа *`-a`* делает необязательной предыдущую команду *`git add`*, и позволяет одновременно и добавить изменения и осуществить их коммит. Например: *`commit -a -m "your comments"`*

* _**`git checkout`**_

    После того как вы нашли ссылку на нужный коммит в истории, для перехода к нему можно использовать команду *`git checkout`*. Команда *`git checkout`* — это простой способ «загрузить» любой из этих сохраненных снимков на компьютер разработчика. 


### 2. _**Определение состояния. Отслеживание измнений.**_
* _**`git status`**_

    Команда *`git status`* показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

* _**`git log`**_

    Команда *`git log`* используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток. Также её можно использовать для просмотра различий между ветками на уровне коммитов.

* _**`git diff`**_

    Команда *`git diff`* используется для вычисления разницы между любыми двумя *Git деревьями*. Это может быть разница между вашей рабочей директорией и индексом (собственно git diff), разница между индексом и последним коммитом (git diff --staged), или между любыми двумя коммитами (git diff master branchB).

* _**`git show [коммит]`**_

    Выводит информацию и показывает изменения в выбранном коммите.

### 3. _**Ветвление.**_
* _**`git branch`**_

    Команда *`git branch`* — это своего рода “*менеджер веток*”. Она умеет перечислять ваши ветки, создавать новые, удалять и переименовывать их.
* *`git branch [имя ветки]`*

    Создаёт новую ветку

* *`git checkout -b new-branch 5589877`*   создает ветку _**new-branch**_, начинающуюся с коммита c хешем _**5589877**_ (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита, создать указатель на этот коммит (ветку) с указанным именем).

* _`git checkout [имя ветки]`_

    Команда *`git checkout`* используется для переключения веток и выгрузки их содержимого в рабочую директорию.
* _`git checkout master `_

    переключение на ветку *master* в последний коммит.

* _`git diff [первая ветка]...[вторая ветка]`_

    Показывает разницу между содержанием коммитов двух веток.

* _**`git log --graph`**_

    Показывает историю комиитов в виде графически прдеставленного "дерева".


### 4. _**Слияние, удаление веток.**_
* _**`git merge`**_

    Команда *`git merge`* используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коммит.

* _**`git mergetool`**_

    Команда *`git mergetool`* просто вызывает внешнюю программу слияний, в случае если у вас возникли проблемы слияния.

* _**`git branch -d [имя ветки]`**_

    Удаляет выбранную ветку.


### 5. _**Настройка `.gitignore`**_

В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. Мы можем удостовериться, что они случайно не попадут в *`git add -A`* при помощи файла _**`.gitignore`**_

Создайте вручную файл под названием _**`.gitignore`**_ и сохраните его в директорию проекта.
Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.
Файл _**`.gitignore`**_ должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.

## **Работа с удалёнными репозиториями**
Для того, чтобы внести вклад в какой-либо _Git-проект_,  Вам необходимо уметь работать с удалёнными репозиториями. 

>! "удаленный репозиторий" - это НЕ ТОТ репозиторий, который Вы когда-то удалили (delete), а репозиторий, находящийся "в облаке".
    
>Вполне возможно, что удалённый репозиторий будет находиться на том же компьютере, на котором работаете вы. Слово «удалённый» не означает, что репозиторий обязательно должен быть где-то в сети или Интернет, а значит только — где-то ещё. Работа с таким удалённым репозиторием подразумевает выполнение стандартных операций отправки и получения, как и с любым другим удалённым репозиторием.

Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У Вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. 

Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. 

Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее.

* _**`git remote`**_

    Команда *`git remote`* служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например _**"origin"**_, так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и *`git remote`* поможет добавлять, изменять и удалять их.

* _**`git fetch`**_

    Команда *`git fetch`* связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

* _**`git pull`**_

    Команда *`git pull`* работает как комбинация команд *`git fetch`* и *`git merge`*, т.е. *Git* вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

* _**`git push`**_

    Команда *`git push`* используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

* _**`git remote show <remote>`**_

    Используйте эту команду для получения больше информации об одном из удалённых репозиториев.

    Например, выполнив эту команду с некоторым именем, например, *`origin`*, она выдаст URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда сообщит Вам, что если Вы, находясь на ветке *master*, выполните *`git pull`*, ветка *master* с удалённого сервера будет автоматически влита в Dашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.
